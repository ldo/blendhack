<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <link rel="stylesheet" type="text/css" href="mystery_of_the_blend.css" media="screen, print">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>The mystery of the blend</title>
</head>

<body>
<div class="title">The mystery of the blend</div>
<div class="subtitle">The Blender file-format explained</div>
<div class="contact">
<label>Authors</label>
   Jeroen Bakker &lt;<a href="mailto:j.bakker@atmind.nl">j.bakker@atmind.nl</a>&gt;,
   Lawrence D'Oliveiro &lt;<a href="mailto:ldo@geek-central.gen.nz">ldo@geek-central.gen.nz</a>&gt;<br>
<label>Version</label> 11-08-2017<br>
</div>

<h2><a name="introduction" href="#introduction" >Introduction</a></h2>

<p>In this article I will describe the blend-file format, hopefully,
 with sufficient detail to allow the writing of tools to read and
 manipulate such files.

</p>
<p>First I'll describe how Blender works with blend-files. You'll notice
 why the blend-file-format is not that well documented, as from
Blender's perspective this is not needed.
We look at the global file-structure of a blend-file (the file-header
and file-blocks).
After this is explained, we go deeper to the core of the blend-file, the
 DNA-structures. They hold the blue-prints of the blend-file and the key
 asset of understanding blend-files.
When that's done we can use these DNA-structures to read information
from elsewhere in the blend-file.

</p>
<p>
In this article we'll be using the default blend-file from Blender 2.54,
 with the goal to read the output resolution from the Scene.
</p>

<h2><a name="loading-and-saving-in-blender" href="#loading-and-saving-in-blender">Loading and saving in Blender</a></h2>

<p>
Loading and saving in Blender is very fast and Blender is known to
have excellent backward compatibility. Ton Roosendaal
demonstrated that in December 2008 by loading a 1.0 blend-file using
Blender 2.48a [ref: <a href="http://www.blendernation.com/2008/12/01/blender-dna-rna-and-backward-compatibility/">http://www.blendernation.com/2008/12/01/blender-dna-rna-and-backward-compatibility/</a>]. Forward compatibility is not quite so good, since newer versions of
Blender may drop structures and fields expected by older versions, or change their
meanings.
</p>

<p>
Saving complex scenes in Blender is done within seconds. Blender
achieves this by saving all the data blocks of the document in memory
to disk without any transformations or translations. Blender only adds
file-block-headers to this data. A file-block-header contains clues on
how to interpret the data. After the data blocks, a “Structure DNA”
block, containing a description of all internal Blender data
structures, is stored. This description will act as a blue-print when
Blender loads the file. Blend-files can be different when stored on
different hardware platforms or Blender releases. There is no effort
taken to make blend-file structures follow an identical layout at the
binary level. Blender creates the blend-files in this manner since
release 1.0. Compatibility is not implemented when saving the file,
this is done during loading.
</p>

<p>A blend-file can also be gzip-compressed to reduce its size.
Blender will automatically recognize this (from the gzip file header)
and apply decompression on loading. The description in the rest of this
document applies to the <i>decompressed</i> file format.

<p>
When Blender loads a blend-file, all blocks are read in sequence into
memory, and then the Structure DNA block is decoded to create a
catalog of all the relevant data structures from the version of
Blender that saved the file. Blender uses this catalog together with
the data in the file, the internal Blender structures of the Blender
release you're using and a lot of transformation and translation logic
to implement the backward compatibility. In the source code of blender
there is actually a whole lot of logic, keyed off the version code in
the file header, which can transform and translate every structure
used by an older Blender release to the one of the release you're
using -- see the version-handling routines in <a
href="https://developer.blender.org/diffusion/B/browse/master/source/blender/blenloader/intern/">source/blender/blenloader/intern/</a>.
As of this writing this conversion logic already totals 11,000 lines
of code, and it can only grow over time. The more difference between
releases, the more of this logic needs to be executed.
</p>

<h2><a name="global-file-structure" href="#global-file-structure">Global file-structure</a></h2>

<p>
This section explains how the global file-structure can be read.
</p>

<ul>
<li>A blend-file always start with the <b>file-header</b></li>
<li>After the file-header, follows a list of <b>file-blocks</b> (the default blend file of Blender 2.72 contains more than 800 of these file-blocks).</li>
<li>Each file-block has a <b>file-block header</b> and <b>file-block data</b></li>
<li>Near the start of the file there must be exactly one <span class="id">GLOB</span> (“globals”) block; this is the root
of the in-memory document structure. It contains pointers to other memory blocks that
make up the document, and they in turn can contain pointers to other blocks, and so on.
In other words, all blocks making up the document can be found by tracing pointers
starting from this block.<br>
For the most part, the structure traced out by these pointers is known as a
<b>directed acyclic graph</b> (DAG);
this means that tracing pointers from any block will not take you back to the same
block again. The exception is doubly-linked list structures linking blocks
which can be traversed by following <tt>next</tt> and <tt>prev</tt> pointers.
<li>Also near the beginning of the file, there may a <span class="id">REND</span> block
and a <span class="id">TEST</span> block.
These blocks, if present, are the only ones allowed to precede the <span class="id">GLOB</span>
block. Also
they are not referenced (directly or indirectly) by pointers from the
<span class="id">GLOB</span> block (nor do they contain any pointer fields).
<li>The <span class="id">REND</span> block, if present, contains a short summary of
the document render
settings: the active scene, and the starting and ending frame number. This is to
allow this information to be easily extracted without having to parse the entire
blend-file.
<li>The <span class="id">TEST</span> block, if present, contains the preview
thumbnail for the document.
Again, this can be easily extracted without having to parse the entire file.
<li>A .blend file used for user preferences (<tt>startup.blend</tt>) may contain
a <span class="id">USER</span> (user-preferences) block.
<li>The penultimate block of the blend-file is the <span class="id">DNA1</span> block
containing the <a href="#structure-DNA" style="font-weight:bold">Structure DNA</a>.</li>
<li>The blend-file ends with a file-block called <span class="id">ENDB</span>. Actually,
this might only
be a partial block--the entire rest of the block structure after the block length might be missing.
This is not important, since Blender stops reading the file after loading the
<span class="id">DNA1</span> block anyway.</li>
</ul>

<!-- file scheme -->
<div class="box-solid" style="width:20%; margin-left:35%; font-size:0.8em;">

    <p class="code"><b>File.blend</b></p>

    <div class="box"><p class="code">File-header</p></div>

    <div class="box-solid"><p class="code">File-block</p>
        <div class="box"><p class="code">Header</p></div>
        <div class="box"><p class="code">Data</p></div>
    </div>

    <div class="box" style="border-style:dashed"><p class="code">File-block</p></div>
    <div class="box" style="border-style:dashed"><p class="code">File-block</p></div>

    <div class="box-solid"><p class="code">File-block 'Structure DNA'</p>
        <div class="box"><p class="code">Header ('DNA1')</p></div>
        <div class="box-solid">
            <p class="code">Data ('SDNA')</p>
            <div class="box">
                <p class="code">Names ('NAME')</p>
            </div>
            <div class="box">
                <p class="code">Types ('TYPE')</p>
            </div>
            <div class="box">
                <p class="code">Lengths ('TLEN')</p>
            </div>
            <div class="box">
                <p class="code">Structures ('STRC')</p>
            </div>
        </div>
    </div>

    <div class="box-solid"><p class="code">File-Block 'ENDB'</p></div>

</div><!-- end of file scheme -->

<h3><a name="file-header" href="#file-header">File-Header</a></h3>

<p>
The first 12 bytes of every blend-file is the file-header. The
file-header has information on Blender’s version-number and important
features of the hardware architecture the
blend-file was saved on (specifically, pointer-size and endianness). This is required
as all data inside the blend-file is ordered in that  way, because no
translation or transformation is done during saving.
The next table describes the information in the file-header.
</p>

<table>
<caption>File-header</caption>
<thead>
<tr><th>reference</th>
    <th>structure</th>
    <th>type</th>
    <th>offset</th>
    <th>size</th></tr>
</thead>
<tbody>
<tr><td>identifier</td>
    <td>char[7]</td>
    <td>File identifier (always 'BLENDER')</td>
    <td>0</td>
    <td>7</td></tr>
<tr><td>pointer-size</td>
    <td>char</td>
    <td>Code indicating the size of a pointer; all pointers in the file are stored in this format. '_' means 4 bytes or 32 bits and '-' means 8 bytes or 64 bits.</td>
    <td>7</td>
    <td>1</td></tr>
<tr><td>endianness</td>
    <td>char</td>
    <td>Code indicating byte ordering used; 'v' means little endian and 'V' means big endian.</td>
    <td>8</td>
    <td>1</td></tr>
<tr><td>version-number</td>
    <td>char[3]</td>
    <td>Version of Blender that saved the file; '254' means version 2.54. This information is
    used during loading to convert fields and structures which look the same, but whose
    meanings have changed.</td>
    <td>9</td>
    <td>3</td></tr>
</tbody>
</table>

<p>
<a href="https://en.wikipedia.org/wiki/Endianness">Endianness</a> addresses the way values are ordered in a sequence of bytes(see the <a href="#example-endianess">example</a> below):
</p>

<ul>
    <li>in a big endian ordering, the largest part of the value is placed on the first byte and
    the lowest part of the value is placed on the last byte,</li>
    <li>in a little endian ordering, largest part of the value is placed on the last byte
    and the smallest part of the value is placed on the first byte.</li>
</ul>

<p>
Nowadays, little-endian is the most commonly used.
</p>

<a name="example-endianess"></a>
<div class="box">
<p onclick="location.href='#example-endianess'" class="box-title">
Endianness Example
</p>
<p>
Writing the integer <code class="evidence">0x4A3B2C1D</code>, the bytes will be ordered
in ascending memory locations as:</p>
<ul>
<li>in big endian as <code class="evidence">0x4A</code>, <code class="evidence">0x3B</code>, <code class="evidence">0x2C</code>, <code class="evidence">0x1D</code></li>
<li>in little endian as <code class="evidence">0x1D</code>, <code class="evidence">0x2C</code>, <code class="evidence">0x3B</code>, <code class="evidence">0x4A</code></li>
</ul>
</div>

<p>
Blender can be built for both little-endian and big-endian architectures.<br>
This means that when the endianness is different between the
blend-file and the machine you are using, your build of Blender converts it on
loading to the byte ordering of your machine.
</p>

<a name="example-file-header"></a>
<div class="box">
<p onclick="location.href='#example-file-header'" class="box-title">
File-header Example
</p>

<p>
This hex-dump describes a file-header created with <code>blender</code> <code>2.54</code> on <code>little-endian</code> hardware with a <code>32 bits</code> pointer length.
<code class="block">                               <span class="descr">pointer-size  version-number
                                     |             |</span>
0000 0000: [42 4C 45 4E 44 45 52]  [5F]  [76]  [32 35 34]        BLENDER_v254  <span class="descr">
                      |                   |
                  identifier          endianness</span></code>
</p>
</div>

<h3><a name="file-blocks" href="#file-blocks">File-blocks</a></h3>

<p>
File-blocks contain a "<a href="#file-block-header">file-block header</a>" and "file-block data".
</p>

<h3><a name="file-block-header" href="#file-block-header">File-block headers</a></h3>

<p>
The file-block-header describes:
</p>

<ul>
<li>the type of information stored in the
file-block</li>
<li>the total length of the data</li>
<li>the old memory
pointer at the moment the data was written to disk</li>
<li>the number of items of this information</li>
</ul>

<p>
As we can see below, depending on the pointer-size stored in the file-header, a file-block-header
can be 20 or 24 bytes long, hence it is always aligned at 4 bytes. To ensure this, the length
of the block data must always be a multiple of 4 bytes.
</p>

<table>
<caption>File-block-header</caption>
<thead>
<tr>
<th>reference</th>
    <th>structure</th>
    <th>type</th>
    <th>offset</th>
    <th>size</th></tr></thead>
<tbody>
<tr><td>code</td>
    <td>char[4]</td>
    <td>File-block identifier</td>
    <td>0</td>
    <td>4</td></tr>
<tr><td>size</td>
    <td>integer</td>
    <td>Total length of the data after the file-block-header</td>
    <td>4</td>
    <td>4</td></tr>
<tr><td>old memory address</td>
    <td>void*</td>
    <td>Memory address the structure was located when written to disk</td>
    <td>8</td>
    <td>pointer-size (4/8)</td></tr>
<tr><td>SDNA index</td>
    <td>integer</td>
    <td>Index of the SDNA structure</td>
    <td>8+pointer-size</td>
    <td>4</td></tr>
<tr><td>count</td>
    <td>integer</td>
    <td>Number of structure located in this file-block</td>
    <td>12+pointer-size</td>
    <td>4</td></tr>
</tbody>
</table>

<p>
The above table describes how a file-block-header is structured:
</p>

<ul>
<li><code>Code</code> describes different types of file-blocks. The code determines with what logic the data must be read.
These codes also allows fast finding of data like Library, Scenes, Object or Materials as they all have a specific code.</li>
<li><code>Size</code> contains the total length of data after the file-block-header.
After the data a new file-block starts.</li>
<li><code>Old memory address</code> contains the memory address when the structure
was last stored. When loading the file the structures can be placed on
different memory addresses. Think of this old-address field as a unique identifier
for the memory block; when Blender sees a pointer field containing that old address, it
updates it to point to the actual memory address for the loaded block.</li>
<li><code>SDNA index</code> contains the index in the DNA structures to be used when
reading this file-block-data. However, this is mainly meaningful in principal blocks--see
below. <br>
More information about this subject will be explained in the <a href="#reading-scene-information">Reading scene information section</a>.</li>
<li><code>Count</code> tells how many elements of the specific SDNA structure can be found in the data. Thus, each block is actually an array of one or more elements of that structure.</li>
</ul>

<p>
There are actually two categories of file blocks, which I will call <i>principal</i>
blocks and <i>subsidiary</i> blocks. A principal block is the root of a major data
structure such as a scene, an object or a material; this in turn can point to
subsidiary blocks, which might in turn point to further subsidiary blocks and
so on. Any of these may contain pointers to other principal blocks, but there
are never any pointers to subsidiary blocks belonging to other principal
blocks. Thus, each subsidiary block belongs to one and only one principal block.
</p>
<p>
Principal blocks have a header code that <i>always ends in two null
bytes</i>. In other words, it is really only a two-letter code. Here
is the current list of valid codes (excluding the trailing nulls), and
the corresponding names of the Blender struct types; they are listed
in the order that older versions of Blender used to write them to the file;
this ordering is not actually important for loading, and is no longer respected
for saving.
</p>

<ul>
<li><span class="id">WM</span> -- <tt>wmWindowManager</tt>
<li><span class="id">SN</span> -- (newer Blender) type <tt>bScreen</tt>
<li><span class="id">SR</span> -- (older Blender) type <tt>bScreen</tt>
<li><span class="id">MC</span> -- <tt>MovieClip</tt>
<li><span class="id">MS</span> -- <tt>Mask</tt>
<li><span class="id">SC</span> -- <tt>Scene</tt>
<li><span class="id">CU</span> -- <tt>Curve</tt>
<li><span class="id">MB</span> -- <tt>MetaBall</tt>
<li><span class="id">IM</span> -- <tt>Image</tt>
<li><span class="id">CA</span> -- <tt>Camera</tt>
<li><span class="id">LA</span> -- <tt>Lamp</tt>
<li><span class="id">IK</span> -- <tt>Ika</tt> (obsolete)
<li><span class="id">LT</span> -- <tt>Lattice</tt>
<li><span class="id">VF</span> -- <tt>VectorFont</tt>
<li><span class="id">KE</span> -- <tt>Key</tt> (shape key)
<li><span class="id">WO</span> -- <tt>World</tt>
<li><span class="id">TX</span> -- <tt>Text</tt>
<li><span class="id">SK</span> -- <tt>Speaker</tt>
<li><span class="id">SO</span> -- <tt>Sound</tt>
<li><span class="id">GR</span> -- <tt>Group</tt>
<li><span class="id">AR</span> -- <tt>bArmature</tt>
<li><span class="id">AC</span> -- <tt>bAction</tt>
<li><span class="id">OB</span> -- <tt>Object</tt>
<li><span class="id">MA</span> -- <tt>Material</tt>
<li><span class="id">TE</span> -- <tt>Tex</tt>(ture)
<li><span class="id">ME</span> -- <tt>Mesh</tt>
<li><span class="id">PA</span> -- <tt>ParticleSettings</tt>
<li><span class="id">NT</span> -- <tt>NodeTree</tt>
<li><span class="id">BR</span> -- <tt>Brush</tt>
<li><span class="id">PL</span> -- <tt>Palette</tt>
<li><span class="id">PC</span> -- <tt>PaintCurve</tt>
<li><span class="id">PY</span> -- <tt>Script</tt> (obsolete)
<li><span class="id">GD</span> -- <tt>GreasePencil</tt>
<li><span class="id">IP</span> -- <tt>Ipo</tt> (obsolete, replaced by <tt>FCurve</tt>s in <span class="id">DATA</span> blocks)
<li><span class="id">LS</span> -- <tt>FreestyleLineStyle</tt>
<li><span class="id">CF</span> -- <tt>CacheFile</tt>
<li><span class="id">LI</span> -- <tt>Library</tt>
</ul>

<p>All these blocks have user-visible names, which must be unique among all
blocks of the same type.</p>

<p>
Subsidiary blocks, on the other hand, always have a code of <span class="id">DATA</span>.
Also, their DNA index field is often zero, instead of specifying a
valid structure type. This means their type has to be deduced from the
target type of a pointer field in some structure that points to them.
Subsidiary blocks appear in the file following the principal block
that (directly or indirectly, through other subsidiary blocks) points
to them, and before the next principal block.
</p>

<p> The <span class="id">USER</span> block (type <tt>UserDef</tt>), if present, is
effectively a kind of principal
block, except it has no nulls in its block code and it is not found by
following pointers from the <span class="id">GLOB</span> block. It, too, can be followed by
subsidiary blocks, containing things like custom keymaps, addon
properties, autoexec paths and style definitions.
</p>

<a name="example-file-block-header"></a>
<div class="box">
<p onclick="location.href='#example-file-block-header'" class="box-title">
Example
</p>
<p>
This hex-dump describes a File-block (= <span class="header">File-block header</span> + <span class="data">File-block data</span>) created with <code>blender</code> <code>2.54</code> on <code>little-endian</code> hardware with a <code>32 bits</code> pointer length.<br>
<code class="block"><span class="descr">             file-block
           identifier='SC'  data size=1404  old pointer   SDNA index=150
                 |              |              |              |</span>
0000 4420: <span class="header">[53 43 00 00]  [7C 05 00 00]  [68 34 FB 0B]  [96 00 00 00]</span>    SC.. `... ./.. ....
0000 4430: <span class="header">[01 00 00 00]</span>  <span class="data">[xx xx xx xx    xx xx xx xx    xx xx xx xx</span>     .... xxxx xxxx xxxx<span class="descr">
                 |              |
              count=1      file-block data (next 1404 bytes)</span>
</code>
</p>

<ul>
<li>The code <span class="id">SC\x00\x00</span> identifies that it is a Scene. </li>
<li>Size of the data is 1404 bytes (0x0000057C = 0x7C + 0x05 * 256 = 124 + 1280)</li>
<li>The old pointer is 0x0BFB3468</li>
<li>The SDNA index is 150 (0x00000096 = 6 + 9 * 16 = 6 + 144)</li>
<li>The section contains a single scene (count = 1).</li>
</ul>

<p>
Before we can interpret the data of this file-block we first have to read the DNA structures in the file.
The section "<a href="#structure-DNA">Structure DNA</a>" will show how to do that.
</p>
</div>

<h2><a name="structure-DNA" href="#structure-DNA">Structure DNA</a></h2>

<h3><a name="DNA1-file-block" href="#DNA1-file-block">The <span class="id">DNA1</span> file-block</a></h3>

<p>
Structure DNA is stored in a file-block with code <span class="id">DNA1</span>.
</p>

<p>
The <span class="id">DNA1</span> file-block contains all internal structures of the
Blender release that
saved the file. <br>
These structures can be described as C-structures: as such, they can hold fields, arrays and
pointers to other structures. Their definitions are collected together in files named
<tt>DNA_</tt><i>*</i><tt>.h</tt> in the directory
<a href="https://developer.blender.org/diffusion/B/browse/master/source/blender/makesdna/">source/blender/makesdna/</a>. Not only are they included from here into the rest of the Blender source
tree as needed, they are also parsed by the <tt>makesdna</tt> utility which is compiled from
this directory and run during build time to generate the Structure DNA block.
This program contains its own simplified C parser for interpreting these structure
definitions; thus they cannot be written using arbitrary C code, but must be
restricted to the subset of C that this parser can cope with.
</p>

<p>
<code class="block">struct SceneRenderLayer {
    struct SceneRenderLayer *next, *prev;
    char name[32];
    struct Material *mat_override;
    struct Group *light_override;
    unsigned int lay;
    unsigned int lay_zmask;
    int layflag;
    int pad;
    int passflag;
    int pass_xor;
};
</code>
</p>

<p>
For example, in a blend-file created with Blender 2.54, the <span class="id">DNA1</span> file-block
is 57796 bytes long and contains 398 structures.
</p>

<h3><a name="DNA1-file-block-header" href="#DNA1-file-block-header"><span class="id">DNA1</span>
file-block-header</a></h3>

<p>
The <span class="id">DNA1</span> file-block header follows the same rules as any other file-block, see the example below.
</p>

<a name="example-DNA1-file-block-header"></a>
<div class="box">
<p onclick="location.href='#example-DNA1-file-block-header'" class="box-title">
Example
</p>
<p>
This hex-dump describes the file-block <span class="id">DNA1</span> header created with <code>blender</code> <code>2.54</code> on <code>little-endian</code> hardware with a <code>32 bits</code> pointer length.<br>
<code class="block"><span class="descr">      (file-block
       identifier='DNA1') data size=57796   old pointer   SDNA index=0
                  |              |              |              |</span>
0004 B060   <span class="header">[44 4E 41 31]  [C4 E1 00 00]  [C8 00 84 0B]  [00 00 00 00]</span>  DNA1............
0004 B070   <span class="header">[01 00 00 00]</span>  <span class="fade">[53 44 4E 41    4E 41 4D 45    CB 0B 00 00</span>   ....<span class="fade">SDNANAME....</span><span class="descr">
                  |              |
              count=1    'DNA1' file-block data (next 57796 bytes)</span>
</code>
</p>
</div>

<h3><a name="DNA1-file-block-data" href="#DNA1-file-block-data">DNA1 file-block data</a></h3>
<p>
The next section describes how this information is ordered in the <b>data</b> of the <span class="id">DNA1</span> file-block.
</p>

<table>
<caption>Structure of the DNA file-block-data</caption>
<thead>
    <tr><th colspan="2">repeat condition</th>
    <th>name</th>
    <th>type</th>
    <th>length</th>
    <th>description</th></tr>
</thead>
<tbody>
<tr><td></td>
    <td></td>
    <td>identifier</td>
    <td>char[4]</td>
    <td>4</td>
    <td>'SDNA'</td></tr>
<tr><td></td>
    <td></td>
    <td>name identifier</td>
    <td>char[4]</td>
    <td>4</td>
    <td>'NAME'</td></tr>
<tr><td></td>
    <td></td>
    <td>#names</td>
    <td>integer</td>
    <td>4</td>
    <td>Number of names follows</td></tr>
<tr><td>for(#names)</td>
    <td></td>
    <td>name</td>
    <td>char[]</td>
    <td>?</td>
    <td>Zero terminating string of name, also contains pointer and simple array definitions (e.g. '*vertex[3]\0')</td></tr>
<tr><td></td>
    <td></td>
    <td>type identifier</td>
    <td>char[4]</td>
    <td>4</td>
    <td>'TYPE' this field is aligned at 4 bytes</td></tr>
<tr><td></td>
    <td></td>
    <td>#types</td>
    <td>integer</td>
    <td>4</td>
    <td>Number of types follows</td></tr>
<tr><td>for(#types)</td>
    <td></td>
    <td>type</td>
    <td>char[]</td>
    <td>?</td>
    <td>Zero terminating string of type (e.g. 'int\0')</td></tr>
<tr><td></td>
    <td></td>
    <td>length identifier</td>
    <td>char[4]</td>
    <td>4</td>
    <td>'TLEN' this field is aligned at 4 bytes</td></tr>
<tr><td>for(#types)</td>
    <td></td>
    <td>length</td>
    <td>short</td>
    <td>2</td>
    <td>Length in bytes of type (e.g. 4)</td></tr>
<tr><td></td>
    <td></td>
    <td>structure identifier</td>
    <td>char[4]</td>
    <td>4</td>
    <td>'STRC' this field is aligned at 4 bytes</td></tr>
<tr><td></td>
    <td></td>
    <td>#structures</td>
    <td>integer</td>
    <td>4</td>
    <td>Number of structures follows</td></tr>
<tr><td>for(#structures)</td>
    <td></td>
    <td>structure type</td>
    <td>short</td>
    <td>2</td>
    <td>Index in types containing the name of the structure</td></tr>
<tr><td>..</td>
    <td></td>
    <td>#fields</td>
    <td>short</td>
    <td>2</td>
    <td>Number of fields in this structure</td></tr>
<tr><td>..</td>
    <td>for(#field)</td>
    <td>field type</td>
    <td>short</td>
    <td>2</td>
    <td>Index in type</td></tr>
<tr><td>for end</td>
    <td>for end</td>
    <td>field name</td>
    <td>short</td>
    <td>2</td>
    <td>Index in name</td></tr>
</tbody>
</table>

<p>
As you can see, the structures are stored in 4 arrays: names, types,
lengths and structures. Each structure definition also contains an array of
fields. A field is the combination of a type and a name. From this
information a catalog of all structures can be constructed.
</p>

<a name="example-DNA1-file-block-data"></a>
<div class="box">
<p onclick="location.href='#example-DNA1-file-block-data'" class="box-title">
Example
</p>
<p>
Created with <code>blender</code> <code>2.54</code> on <code>little-endian</code> hardware with a <code>32 bits</code> pointer length.
</p>

<h4><a name="DNA1-data-array-names" href="#DNA1-data-array-names">The names array</a></h4>
<p>
This contains the names of the fields of the struct types. Each name is terminated by
a null byte; it is implicitly assigned an index in turn from 0, and this index is used
in the field definition to refer back to the name.
<code class="block"><span class="descr">    file-block-data identifier='SDNA'  array-id='NAME'     number of names=3019
                                |              |             |</span>
0004 B070    <span class="fade">01 00  00 00 [53 44  4E 41]</span><span class="data">[4E  41 4D 45] [CB 0B 00  00]</span>  <span class="fade">....SDNA</span>NAME....
0004 B080   <span class="data">[2A 6E  65 78  74 00][2A 70  72  65 76 00] [2A 64 61  74</span>   *next.*prev.*dat<span class="descr">
                      |                    |                   |
                  '*next\0'            '*prev\0'            '*dat'</span><span class="fade">
                                  ....
                                  .... (3019 names)</span>
</code>
</p>

<div class="box">
<p class="box-title">
<b>Pointer, array and method types:</b>
</p>
<p>
Blender also allows for fields of struct types to have pointer, array and method types derived
from the primitive types and other struct types. These are defined by using special forms for their
names in the names array:
<ul>
<li>“<tt>*</tt><i>name</i>” indicates that the field <i>name</i> is actually a pointer to the
data type referenced in the field definition.
<li>“<i>name</i><tt>[</tt><i>nr_elts</i><tt>]</tt>” (where <i>nr_elts</i> is a decimal whole
number) indicates that the field <i>name</i> is actually
an array of <i>nr_elts</i> elements of the type referenced in the field definition.
<li>“<tt>(*</tt><i>name</i><tt>)()</tt>” or“<tt>(*</tt><i>name</i><tt>)(void)</tt>” indicates that the field <i>name</i>
is actually a pointer to a method returning the type referenced in the field definition.
Note that the method argument types are not defined.
</li>
</ul>
<p class="box-title">
<b>Dangling pointers:</b>
<p>In the data blocks, all the method pointer fields, and some of the data pointer fields,
contain invalid addresses.
That is, their values do not correspond to the old-address fields assigned to any
of the blocks in the file. Blender doesn’t care about the on-disk values of these fields;
it replaces them with its own valid in-memory values after the blocks have been loaded.
</p>
<p class="box-title">
<b>Potential data leakage:</b>
<p>A couple of design decisions potentially lead to the inclusion of information
in the .blend file that rightly should not belong there:
<ul>
<li>All pointer fields (both data pointers and method pointers) contain addresses
that their targets had in memory before being saved. When you think about the factors
that affect this address assignment, you can see how this could leak subtle information
about the user’s Blender installation, build options etc.
<li>String fields are null-terminated. When a longer value is changed to a shorter
value, Blender inserts a terminating null immediately after the new string value,
but leaves the rest of the field (if any) with its previous contents. This could leak
information about the user’s prior activity with that file.
</ul>
</div>

<h4><a name="DNA1-data-array-types" href="#DNA1-data-array-types">The types array</a></h4>
<p>
This has the same structure as the names array (above), but it defines the names of
all the types, and the affixes for pointer/array/method types are not allowed.
As before, each name is terminated by a null byte, and is implicitly
assigned an index in turn from 0, which becomes the index for referring to that type.
</p>
<p>
The types array always begins with the <i>primitive</i> (non-struct) types:
<tt>char</tt>, <tt>uchar</tt>, <tt>short</tt>, <tt>ushort</tt>, <tt>int</tt>, <tt>long</tt>, <tt>ulong</tt>, <tt>float</tt>, <tt>double</tt>, <tt>void</tt> (note that there is no <tt>uint</tt>).
Following these are the names of the struct types: each struct definition (below) specifies
the index of the type name that is to be associated with it.

<code class="block"><span class="descr">                                                      array-id='TYPE'
                                                            |</span>
0005 2440    <span class="fade">6F 6C 64 5B   34 5D 5B 34 5D 00 00 00</span>   [54 59 50  45]  <span class="fade">old[4][4]...</span>TYPE
0005 2450   [C9 01 00 00] [63 68 61 72 00]  [75 63 68 61 72 00][73   ....char.uchar.s<span class="descr">
                  |                |                 |           |
       number of types=457     'char\0'          'uchar\0'      's'</span><span class="fade">
                                  ....
                                  .... (457 types)</span>
</code>
</p>

<h4><a name="DNA1-data-array-lengths" href="#DNA1-data-array-lengths">The lengths array</a></h4>
<p>
This specifies the size in bytes of each type.
<code class="block"><span class="descr">                                                 char    uchar    ushort   short
                                 array-id       length   length   length   length
                                   'TLEN'          1        1        2        2</span>
0005 3AA0    <span class="fade">45 00    00 00</span>   [54 4C    45 4E]  [01 00]  [01 00]  [02 00]  [02 00]  <span class="fade">E...</span>TLEN........
                                  <span class="fade">....</span>
0005 3AC0   [08 00]  [04 00]  [08 00]  [10 00]  [10 00]  [14 00]  [4C 00]  [34 00]  ............L.4.<span class="descr">
               8        4        8
           ListBase   vec2s    vec2f    ... etc
           length     len      length   </span><span class="fade">
                                  ....
                                  .... (457 lengths, same as number of types)</span>
</code>
</p>

<h4><a name="DNA1-data-array-structures" href="#DNA1-data-array-structures">The structures array</a></h4>
<p>
Here is where the struct types are defined. The first struct type (with index 0) is always
the <b>Link</b> type: this is treated specially, since in subsidiary block headers (see above), a struct index of 0
does not actually mean the block is of <b>Link</b> type!
<code class="block"><span class="descr">                                                                 array-id='STRC'
                                                                        |</span>
0005 3E30    <span class="fade">40 00 38 00   60 00   00 00     00 00     00 00</span>    [53 54     52 43]  <span class="fade">@.8.`.......</span>STRC
0005 3E40   [8E 01 00 00] [0A 00] [02 00]   [0A 00]   [00 00]   [0A 00]   [01 00]  ................<span class="descr">
                 398         10      2         10        0         10        0
              number of    index    fields    index     index     index     index
             structures   in <a href="#DNA1-data-array-types">types</a>           in <a href="#DNA1-data-array-types">types</a>  in <a href="#DNA1-data-array-names">names</a>  in <a href="#DNA1-data-array-types">types</a>   in <a href="#DNA1-data-array-names">names</a></span><span class="fade">
                          '                  '----------------'  '-----------------'                                    '
                          '                      field 0                field 1    '
                          '--------------------------------------------------------'
                                             structure 0
                                  ....
                                  .... (398 structures, each one describeing own type, and type/name for each field)</span>
</code>
</p>
</div>

<p>

<b>Type index versus struct index:</b> In a block header, the DNA index is the index into
the structures array, not the type array--in other words, blocks must always be of struct types,
never primitive types. However, in a field definition within the structures array, the
field type is the index into the type array, allowing for fields of any type,
primitive or structured.
</p>

<p>If we understand the DNA part of the file it is now possible to read
information from other parts file-blocks. The next section will tell us
how.
</p>

<h2><a name="reading-scene-information" href="#reading-scene-information">Reading scene information</a></h2>

<p>
Let us look at <a href="#example-file-block-header">the file-block header we have seen earlier</a>:<br>
</p>
<ul>
<li>the file-block identifier is <span class="id">SC\x00\x00</span></li>
<li>the SDNA index is 150</li>
<li>the file-block size is 1404 bytes</li>
</ul>
<p>
Now note that:
<ul>
<li>the structure at index 150 in the DNA is a structure of type 'Scene' (counting from 0).</li>
<li>the associated type ('Scene') in the DNA has the length of 1404 bytes.</li>
</ul>

<p>
We can map the Scene structure on the data of the file-blocks.
But before we can do that, we have to flatten the Scene-structure.

<code class="block">struct Scene {
    ID id;              <span class="descr">// 52 bytes long (ID is different a structure)</span>
    AnimData *adt;      <span class="descr">// 4 bytes long (pointer to an AnimData structure)</span>
    Object *camera;     <span class="descr">// 4 bytes long (pointer to an Object structure)</span>
    World *world;       <span class="descr">// 4 bytes long (pointer to an Object structure)</span>
    ...
    float cursor[3];    <span class="descr">// 12 bytes long (array of 3 floats)</span>
    ...
};
</code>

The first field in the Scene-structure is of type <tt>ID</tt> with the name <tt>id</tt>.
Inside the list of DNA structures there is a structure defined for type 'ID' (structure index 17).

<code class="block">struct ID {
    void *next, *prev;
    struct ID *newid;
    struct Library *lib;
    char name[24];
    short us;
    short flag;
    int icon_id;
    IDProperty *properties;
};
</code>

The first field in this structure has type 'void' and name '*next'. <br>
Looking in the structure list there is no structure defined for type 'void': it is a simple type and therefore the data should be read.
The name '*next' describes a pointer.
As we see, the first 4 bytes of the data can be mapped to 'id.next'.
</p>

<p>
Using this method we'll map a structure to its data. If we want to
read a specific field we know at which offset in the data it is located
and how much space it takes.<br>
The next table shows the output of this flattening process for some
parts of the Scene-structure. Not all rows are described in the table as
 there is a lot of information in a Scene-structure.
</p>

<table>
<caption>Flattened SDNA structure 150: Scene</caption>
<thead>
<tr><th>reference</th>
    <th>structure</th>
    <th>type</th><th>name</th>
    <th>offset</th><th>size</th>
    <th>description</th></tr>
</thead>
<tbody>
<tr><td>id.next</td><td><a href="#struct:ID">ID</a></td>
    <td>void</td><td>*next</td>
    <td>0</td>
    <td>4</td>
    <td>Refers to the next scene</td></tr>
<tr><td>id.prev</td><td><a href="#struct:ID">ID</a></td>
    <td>void</td><td>*prev</td>
    <td>4</td>
    <td>4</td>
    <td>Refers to the previous scene</td></tr>
<tr><td>id.newid</td><td><a href="#struct:ID">ID</a></td>
    <td>ID</td><td>*newid</td>
    <td>8</td>
    <td>4</td>
    <td></td></tr>
<tr><td>id.lib</td><td><a href="#struct:ID">ID</a></td>
    <td>Library</td><td>*lib</td>
    <td>12</td>
    <td>4</td>
    <td></td></tr>
<tr><td>id.name</td><td><a href="#struct:ID">ID</a></td>
    <td>char</td><td>name[24]</td>
    <td>16</td>
    <td>24</td>
    <td>'SC'+the name of the scene as displayed in Blender</td></tr>
<tr><td>id.us</td><td><a href="#struct:ID">ID</a></td>
    <td>short</td><td>us</td>
    <td>40</td>
    <td>2</td>
    <td></td></tr>
<tr><td>id.flag</td><td><a href="#struct:ID">ID</a></td>
    <td>short</td><td>flag</td><td>42</td><td>2</td>
    <td></td></tr>
<tr><td>id.icon_id</td><td><a href="#struct:ID">ID</a></td>
    <td>int</td><td>icon_id</td><td>44</td>
    <td>4</td>
    <td></td></tr>
<tr><td>id.properties</td><td><a href="#struct:ID">ID</a></td>
    <td>IDProperty</td><td>*properties</td>
    <td>48</td>
    <td>4</td>
    <td></td></tr>
<tr><td>adt</td><td>Scene</td><td>AnimData</td>
    <td>*adt</td>
    <td>52</td>
    <td>4</td>
    <td></td></tr>
<tr><td>camera</td><td>Scene</td>
    <td>Object</td>
    <td>*camera</td>
    <td>56</td>
    <td>4</td>
    <td>Pointer to the current camera</td></tr>
<tr><td>world</td><td>Scene</td>
    <td>World</td>
    <td>*world</td>
    <td>60</td>
    <td>4</td>
    <td>Pointer to the current world</td></tr>

<tr><td class="skip" colspan="7">Skipped rows</td></tr>

<tr><td>r.xsch</td><td><a href="#struct:RenderData">RenderData</a>
    </td><td>short</td><td>xsch</td><td>382</td><td>2</td>
    <td>X-resolution of the output when rendered at 100%</td></tr>
<tr><td>r.ysch</td><td><a href="#struct:RenderData">RenderData</a>
    </td><td>short</td><td>ysch</td><td>384</td><td>2</td>
    <td>Y-resolution of the output when rendered at 100%</td></tr>
<tr><td>r.xparts</td><td><a href="#struct:RenderData">RenderData</a>
    </td><td>short</td><td>xparts</td><td>386</td><td>2</td>
    <td>Number of x-part used by the renderer</td></tr>
<tr><td>r.yparts</td><td><a href="#struct:RenderData">RenderData</a>
    </td><td>short</td><td>yparts</td><td>388</td><td>2</td>
    <td>Number of x-part used by the renderer</td></tr>

<tr><td class="skip" colspan="7">Skipped rows</td></tr>

<tr><td>gpd</td><td>Scene</td><td>bGPdata</td><td>*gpd</td><td>1376</td><td>4</td>
    <td></td></tr>
<tr><td>physics_settings.gravity</td><td><a href="#struct:PhysicsSettings">PhysicsSettings</a>
    </td><td>float</td><td>gravity[3]</td><td>1380</td><td>12</td>
    <td></td></tr>
<tr><td>physics_settings.flag</td><td><a href="#struct:PhysicsSettings">PhysicsSettings</a>
    </td><td>int</td><td>flag</td><td>1392</td><td>4</td>
    <td></td></tr>
<tr><td>physics_settings.quick_cache_step</td><td><a href="#struct:PhysicsSettings">PhysicsSettings</a>
    </td><td>int</td><td>quick_cache_step</td><td>1396</td><td>4</td>
    <td></td></tr>
<tr><td>physics_settings.rt</td><td><a href="#struct:PhysicsSettings">PhysicsSettings</a>
    </td><td>int</td><td>rt</td><td>1400</td><td>4</td>
    <td></td></tr>
</tbody>
</table>

<p>
We can now read the X and Y resolution of the Scene:
<ul>
<li>the X-resolution is located on offset 382 of the file-block-data and must be read as a
short.</li>
<li>the Y-resolution is located on offset 384 and is also a short</li>
</ul>

<div class="box">
<p class="box-title">
Note
</p>
<p>
An array of <tt>char</tt>s can mean 2 things. The field contains readable
text (null-terminated) or it contains an array of flags (not humanly readable). You’d
think that <tt>uchar</tt> would be the logical type to use for the
latter, but in fact this type does not seem to be used.
</p>
</div>

<div class="box">
<p class="box-title">
Note
</p>
<p>
A file-block containing a list refers to the DNA structure and has a count larger
than 1. For example Vertices and Faces are stored in this way.
</p>
</div>

<h2><a name="conclusion" href="#conclusion" >Conclusion</a></h2>

<p>There are clearly some haphazard aspects to the file format design:
<span class="id">DATA</span> blocks with incorrect structure codes,
dangling data pointers, null-terminated string fields containing
trailing junk from previous values, the unused <tt>uchar</tt> type,
and the unfiltered saving of in-memory addresses in pointer fields are
all signs of a format which has prioritized working code over a clean
design. This was never intended as an interchange file format!</p>
<p>
Consider also that 64-bit builds of Blender save full 64-bit pointer
fields on disk: while Blender can easily use multiple gigabytes of RAM
for in-memory purposes like physics simulations, rendering etc, actual
multi-gigabyte .blend files would be rare--perhaps rare enough to make
it worthwhile to have the option to write files with only 32-bit block
IDs. However, in my (admittedly limited) measurements, the saving with
larger .blend files amounts to no more than 1-2%. The biggest relative
saving I have found so far was with Blender’s own
<tt>startup.blend</tt>, where converting from 64-bit pointers to 32-bit
ones shrank it 12% from its original size of about 430KB.
</p>
<p>
Still, the format has proven its ability to adapt and evolve to meet
ever more sophisticated needs, and the technique for achieving
cross-architectural and backward compatibility is clever. Keeping the
ability to open old Blender files right back to the earliest versions
is a never-ending, ever-increasing commitment; it is to the credit of
the Blender developers that they show no signs of ever giving up on
this.
</p>

</body>
</html>
