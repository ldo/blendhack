#!/usr/bin/python3
#+
# Test of trying to parse the contents of .blend files created by
# Blender <http://www.blender.org/>, and make basic modifications
# to them. Invoke this script as follows:
#
#     blendhack blendfile [outfile]
#
# where blendfile is the name of a .blend file to analyze, and outfile
# is an optional output .blend file to try creating.
# The output of the script will be a dump of the decoded file contents.
#
# Copyright 2012-2021 Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#-

import sys
import io
import logging
import getopt
import blendfile

def dict_repr(d) :
  # ensure dictionary items come out in consistent order
    if type(d) == dict :
        result = \
            (
                "{"
            +
                ", ".join(dict_repr(key) + ": " + dict_repr(d[key]) for key in sorted(d))
            +
                "}"
            )
    elif type(d) == tuple :
        result = "(" + ", ".join(dict_repr(item) for item in d) + ")"
    elif type(d) == list :
        result = "[" + ", ".join(dict_repr(item) for item in d) + "]"
    else :
        result = repr(d)
    #end if
    return \
        result
#end dict_repr

#+
# Mainline
#-

opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ("bits=", "compression=", "decode-untyped=", "endian=", "loglevel=", "raw", "remap", "save-oldaddrs"),
  )
if len(args) not in (1, 2) :
    raise getopt.GetoptError("usage: %s blendfile [outfile]" % sys.argv[0])
#end if
bit64 = None
big_endian = None
compression = None
debug = False
decode_untyped = True
use_rawdata = False
do_remap = False
save_oldaddrs = False
loglevel = None
for keyword, value in opts :
    if keyword == "--bits" :
        bit64 = {32 : False, 64 : True}[int(value)]
    elif keyword == "--compression" :
        compression = list(c for c in blendfile.COMPRESSION if c.name == value.lower())
        if len(compression) > 0 :
            compression = compression[0]
        else :
            raise getopt.GetoptError("unrecognized compression format %s" % value)
        #end if
    elif keyword == "--decode-untyped" :
        decode_untyped = value[:1].lower() in ("y", "t", "1")
    elif keyword == "--endian" :
        big_endian = {"big" : True, "little" : False}[value.lower()]
    elif keyword == "--loglevel" :
        try :
            loglevel = int(value)
        except ValueError :
            loglevel = logging._nameToLevel.get(value.upper())
        #end try
        if loglevel == None :
            raise getopt.GetoptError("invalid numeric or symbolic level %s" % repr(value))
        #end if
        logging.basicConfig(level = loglevel)
    elif keyword == "--raw" :
        use_rawdata = True
    elif keyword == "--remap" :
        do_remap = True
    elif keyword == "--save-oldaddrs" :
        save_oldaddrs = True
    #end if
#end for
blend = blendfile.Blenddata(loglevel = loglevel).load(args[0], decode_untyped = decode_untyped, keep_rawdata = use_rawdata, count_refs = True)
for i, block in enumerate(blend.blocks) :
    if block["decoded"] :
        referenced = io.StringIO()
        referrers = block.get("refs")
        if referrers != None and len(referrers) != 0 :
            first = True
            referenced.write(" refs(%d): " % len(referrers))
            for referrer in referrers :
                if len(referrer) != 0 :
                    assert type(referrer[0]) == dict, "referrer does not begin with block dict"
                    if first :
                        first = False
                    else :
                        referenced.write(", ")
                    #end if
                    referenced.write("block[%d]" % referrer[0]["index"])
                    for elt in referrer[1:] :
                        if type(elt) == int :
                            referenced.write("[%d]" % elt)
                        elif type(elt) == str :
                            referenced.write("." + elt)
                        else :
                            raise AssertionError("type of %s not int index or string field name" % repr(elt))
                        #end if
                    #end for
                else :
                    referenced.write("()")
                #end if
            #end for
        else :
            referenced.write(" - no refs to this block")
        #end if
        blend.logger.debug \
          (
                "* block[%d](%s)[%s]@%#x : %s[%d]%s"
            %
                (
                    i,
                    repr(block["code"]),
                    len(block.get("rawdata", "")),
                    block["oldaddr"],
                    blendfile.type_name(block["type"]),
                    block["dna_count"],
                    referenced.getvalue(),
                )
          )
        if type(block["data"]) in (tuple, list) :
            if blendfile.type_name(block["type"]) == "char" :
                blend.logger.debug \
                  (
                        " => %s"
                    %
                        repr(b"".join(item for item in block["data"]))
                  )
            else :
                for i, item in enumerate(block["data"]) :
                    blend.logger.debug \
                      (
                            "[%d] => %s"
                        %
                            (i, dict_repr(item))
                      )
                #end for
            #end if
        else :
            blend.logger.debug(" => %s" % repr(block["data"]))
        #end if
    else :
        blend.logger.debug("block[%d] undecoded" % i)
    #end if
#end for
if len(args) > 1 :
    remap = {}
      # try fiddling with address fields
    def remap_addr(addr) :
        if addr not in remap :
            remap[addr] = len(remap) + 1
        #end if
        return \
            remap[addr]
    #end remap_addr

    def remap_block(block) :

        def remap_refs(data, datatype) :
            result = data # initial assumption
            if type(datatype) == blendfile.PointerType :
                if type(data) == blendfile.DanglingPointer :
                    data.addr = remap_addr(data.addr)
                elif type(data) == blendfile.BlockRef :
                    data.block["index"] = remap_addr(data.block["index"])
                #end if
            elif type(datatype) == blendfile.FixedArrayType :
                if datatype.EltType != blend.types["char"] :
                    for i in range(len(data)) :
                        remap_refs(data[i], datatype.EltType)
                    #end for
                #end if
            elif type(datatype) == blendfile.MethodType :
                pass
            elif datatype["name"] in blendfile.primitive_types :
                pass
            elif blendfile.is_struct_type(datatype) and type(data) == dict :
                for field in datatype["fields"] :
                    remap_refs \
                      (
                        (data.__getitem__, data.get)[datatype == blend.link_type](field["name"]),
                        field["type"]
                      )
                #end for
            #end if
        #end remap_refs

    #begin remap_block
        if "data" in block :
            datatype = blend.structs_by_index[block["dna_index"]]
            if type(block["data"]) in (tuple, list) :
                for i in range(len(block["data"])) :
                    remap_refs(block["data"][i], datatype)
                #end for
            #end if
        #end if
    #end remap_block

    if do_remap :
        for block in blend.blocks :
            remap_addr(block["oldaddr"])
        #end for
        for block in blend.blocks :
            remap_block(block)
        #end for
    #end if

    blend.save \
      (
        filename = args[1],
        bit64 = bit64,
        big_endian = big_endian,
        compression = compression,
        encode_ref = (lambda block : block["index"], lambda block : block["oldaddr"])[save_oldaddrs],
        use_rawdata = use_rawdata,
      )
#end if
